# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T02:39:21+00:00

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class Type(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    EDDYSTONE = 'EDDYSTONE'
    IBEACON = 'IBEACON'
    ALTBEACON = 'ALTBEACON'
    EDDYSTONE_EID = 'EDDYSTONE_EID'


class AdvertisedId(BaseModel):
    id: Optional[str] = Field(
        None,
        description='The actual beacon identifier, as broadcast by the beacon hardware. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. The base64 encoding should be of the binary byte-stream and not any textual (such as hex) representation thereof. Required.',
    )
    type: Optional[Type] = Field(
        None, description='Specifies the identifier type. Required.'
    )


class AttachmentInfo(BaseModel):
    data: Optional[str] = Field(
        None, description='An opaque data container for client-provided data.'
    )
    maxDistanceMeters: Optional[float] = Field(
        None,
        description='The distance away from the beacon at which this attachment should be delivered to a mobile app. Setting this to a value greater than zero indicates that the app should behave as if the beacon is "seen" when the mobile device is less than this distance away from the beacon. Different attachments on the same beacon can have different max distances. Note that even though this value is expressed with fractional meter precision, real-world behavior is likley to be much less precise than one meter, due to the nature of current Bluetooth radio technology. Optional. When not set or zero, the attachment should be delivered at the beacon\'s outer limit of detection.',
    )
    namespacedType: Optional[str] = Field(
        None,
        description='Specifies what kind of attachment this is. Tells a client how to interpret the `data` field. Format is namespace/type, for example scrupulous-wombat-12345/welcome-message',
    )


class ExpectedStability(Enum):
    STABILITY_UNSPECIFIED = 'STABILITY_UNSPECIFIED'
    STABLE = 'STABLE'
    PORTABLE = 'PORTABLE'
    MOBILE = 'MOBILE'
    ROVING = 'ROVING'


class Status(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    ACTIVE = 'ACTIVE'
    DECOMMISSIONED = 'DECOMMISSIONED'
    INACTIVE = 'INACTIVE'


class BeaconAttachment(BaseModel):
    attachmentName: Optional[str] = Field(
        None,
        description='Resource name of this attachment. Attachment names have the format: beacons/ beacon_id/attachments/attachment_id. Leave this empty on creation.',
    )
    creationTimeMs: Optional[str] = Field(
        None,
        description='The UTC time when this attachment was created, in milliseconds since the UNIX epoch.',
    )
    data: Optional[str] = Field(
        None,
        description='An opaque data container for client-provided data. Must be [base64](http://tools.ietf.org/html/rfc4648#section-4) encoded in HTTP requests, and will be so encoded (with padding) in responses. Required.',
    )
    maxDistanceMeters: Optional[float] = Field(
        None,
        description='The distance away from the beacon at which this attachment should be delivered to a mobile app. Setting this to a value greater than zero indicates that the app should behave as if the beacon is "seen" when the mobile device is less than this distance away from the beacon. Different attachments on the same beacon can have different max distances. Note that even though this value is expressed with fractional meter precision, real-world behavior is likley to be much less precise than one meter, due to the nature of current Bluetooth radio technology. Optional. When not set or zero, the attachment should be delivered at the beacon\'s outer limit of detection. Negative values are invalid and return an error.',
    )
    namespacedType: Optional[str] = Field(
        None,
        description='Specifies what kind of attachment this is. Tells a client how to interpret the `data` field. Format is namespace/type. Namespace provides type separation between clients. Type describes the type of `data`, for use by the client when parsing the `data` field. Required.',
    )


class BeaconInfo(BaseModel):
    advertisedId: Optional[AdvertisedId] = Field(
        None, description='The ID advertised by the beacon.'
    )
    attachments: Optional[List[AttachmentInfo]] = Field(
        None,
        description='Attachments matching the type(s) requested. May be empty if no attachment types were requested.',
    )
    beaconName: Optional[str] = Field(
        None, description='The name under which the beacon is registered.'
    )


class Date(BaseModel):
    day: Optional[int] = Field(
        None,
        description="Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.",
    )
    month: Optional[int] = Field(
        None,
        description='Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.',
    )
    year: Optional[int] = Field(
        None,
        description='Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.',
    )


class DeleteAttachmentsResponse(BaseModel):
    numDeleted: Optional[int] = Field(
        None, description='The number of attachments that were deleted.'
    )


class Alert(Enum):
    ALERT_UNSPECIFIED = 'ALERT_UNSPECIFIED'
    WRONG_LOCATION = 'WRONG_LOCATION'
    LOW_BATTERY = 'LOW_BATTERY'
    LOW_ACTIVITY = 'LOW_ACTIVITY'


class Diagnostics(BaseModel):
    alerts: Optional[List[Alert]] = Field(
        None, description='An unordered list of Alerts that the beacon has.'
    )
    beaconName: Optional[str] = Field(
        None,
        description='Resource name of the beacon. For Eddystone-EID beacons, this may be the beacon\'s current EID, or the beacon\'s "stable" Eddystone-UID.',
    )
    estimatedLowBatteryDate: Optional[Date] = Field(
        None,
        description='The date when the battery is expected to be low. If the value is missing then there is no estimate for when the battery will be low. This value is only an estimate, not an exact date.',
    )


class Empty(BaseModel):
    pass


class EphemeralIdRegistration(BaseModel):
    beaconEcdhPublicKey: Optional[str] = Field(
        None,
        description="The beacon's public key used for the Elliptic curve Diffie-Hellman key exchange. When this field is populated, `service_ecdh_public_key` must also be populated, and `beacon_identity_key` must not be.",
    )
    beaconIdentityKey: Optional[str] = Field(
        None,
        description='The private key of the beacon. If this field is populated, `beacon_ecdh_public_key` and `service_ecdh_public_key` must not be populated.',
    )
    initialClockValue: Optional[str] = Field(
        None,
        description="The initial clock value of the beacon. The beacon's clock must have begun counting at this value immediately prior to transmitting this value to the resolving service. Significant delay in transmitting this value to the service risks registration or resolution failures. If a value is not provided, the default is zero.",
    )
    initialEid: Optional[str] = Field(
        None,
        description='An initial ephemeral ID calculated using the clock value submitted as `initial_clock_value`, and the secret key generated by the Diffie-Hellman key exchange using `service_ecdh_public_key` and `service_ecdh_public_key`. This initial EID value will be used by the service to confirm that the key exchange process was successful.',
    )
    rotationPeriodExponent: Optional[int] = Field(
        None,
        description='Indicates the nominal period between each rotation of the beacon\'s ephemeral ID. "Nominal" because the beacon should randomize the actual interval. See [the spec at github](https://github.com/google/eddystone/tree/master/eddystone-eid) for details. This value corresponds to a power-of-two scaler on the beacon\'s clock: when the scaler value is K, the beacon will begin broadcasting a new ephemeral ID on average every 2^K seconds.',
    )
    serviceEcdhPublicKey: Optional[str] = Field(
        None,
        description="The service's public key used for the Elliptic curve Diffie-Hellman key exchange. When this field is populated, `beacon_ecdh_public_key` must also be populated, and `beacon_identity_key` must not be.",
    )


class EphemeralIdRegistrationParams(BaseModel):
    maxRotationPeriodExponent: Optional[int] = Field(
        None,
        description='Indicates the maximum rotation period supported by the service. See EddystoneEidRegistration.rotation_period_exponent',
    )
    minRotationPeriodExponent: Optional[int] = Field(
        None,
        description='Indicates the minimum rotation period supported by the service. See EddystoneEidRegistration.rotation_period_exponent',
    )
    serviceEcdhPublicKey: Optional[str] = Field(
        None,
        description="The beacon service's public key for use by a beacon to derive its Identity Key using Elliptic Curve Diffie-Hellman key exchange.",
    )


class GetInfoForObservedBeaconsResponse(BaseModel):
    beacons: Optional[List[BeaconInfo]] = Field(
        None,
        description='Public information about beacons. May be empty if the request matched no beacons.',
    )


class IndoorLevel(BaseModel):
    name: Optional[str] = Field(None, description='The name of this level.')


class LatLng(BaseModel):
    latitude: Optional[float] = Field(
        None,
        description='The latitude in degrees. It must be in the range [-90.0, +90.0].',
    )
    longitude: Optional[float] = Field(
        None,
        description='The longitude in degrees. It must be in the range [-180.0, +180.0].',
    )


class ListBeaconAttachmentsResponse(BaseModel):
    attachments: Optional[List[BeaconAttachment]] = Field(
        None, description='The attachments that corresponded to the request params.'
    )


class ListDiagnosticsResponse(BaseModel):
    diagnostics: Optional[List[Diagnostics]] = Field(
        None, description='The diagnostics matching the given request.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='Token that can be used for pagination. Returned only if the request matches more beacons than can be returned in this response.',
    )


class ServingVisibility(Enum):
    VISIBILITY_UNSPECIFIED = 'VISIBILITY_UNSPECIFIED'
    UNLISTED = 'UNLISTED'
    PUBLIC = 'PUBLIC'


class Namespace(BaseModel):
    namespaceName: Optional[str] = Field(
        None,
        description='Resource name of this namespace. Namespaces names have the format: namespaces/namespace.',
    )
    servingVisibility: Optional[ServingVisibility] = Field(
        None,
        description='Specifies what clients may receive attachments under this namespace via `beaconinfo.getforobserved`.',
    )


class Observation(BaseModel):
    advertisedId: Optional[AdvertisedId] = Field(
        None,
        description='The ID advertised by the beacon the client has encountered. If the submitted `advertised_id` type is Eddystone-EID, then the client must be authorized to resolve the given beacon. Otherwise no data will be returned for that beacon. Required.',
    )
    telemetry: Optional[str] = Field(
        None,
        description='The array of telemetry bytes received from the beacon. The server is responsible for parsing it. This field may frequently be empty, as with a beacon that transmits telemetry only occasionally.',
    )
    timestampMs: Optional[str] = Field(
        None, description='Time when the beacon was observed.'
    )


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class AlertFilter(Enum):
    ALERT_UNSPECIFIED = 'ALERT_UNSPECIFIED'
    WRONG_LOCATION = 'WRONG_LOCATION'
    LOW_BATTERY = 'LOW_BATTERY'
    LOW_ACTIVITY = 'LOW_ACTIVITY'


class Beacon(BaseModel):
    advertisedId: Optional[AdvertisedId] = Field(
        None,
        description='The identifier of a beacon as advertised by it. This field must be populated when registering. It may be empty when updating a beacon record because it is ignored in updates. When registering a beacon that broadcasts Eddystone-EID, this field should contain a "stable" Eddystone-UID that identifies the beacon and links it to its attachments. The stable Eddystone-UID is only used for administering the beacon.',
    )
    beaconName: Optional[str] = Field(
        None,
        description='Resource name of this beacon. A beacon name has the format "beacons/N!beaconId" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon\'s type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.',
    )
    description: Optional[str] = Field(
        None,
        description='Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.',
    )
    ephemeralIdRegistration: Optional[EphemeralIdRegistration] = Field(
        None,
        description='Write-only registration parameters for beacons using Eddystone-EID (remotely resolved ephemeral ID) format. This information will not be populated in API responses. When submitting this data, the `advertised_id` field must contain an ID of type Eddystone-UID. Any other ID type will result in an error.',
    )
    expectedStability: Optional[ExpectedStability] = Field(
        None,
        description='Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.',
    )
    indoorLevel: Optional[IndoorLevel] = Field(
        None,
        description='The indoor level information for this beacon, if known. As returned by the Google Maps API. Optional.',
    )
    latLng: Optional[LatLng] = Field(
        None,
        description='The location of the beacon, expressed as a latitude and longitude pair. This location is given when the beacon is registered or updated. It does not necessarily indicate the actual current location of the beacon. Optional.',
    )
    placeId: Optional[str] = Field(
        None,
        description='The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.',
    )
    properties: Optional[Dict[str, str]] = Field(
        None,
        description='Properties of the beacon device, for example battery type or firmware version. Optional.',
    )
    provisioningKey: Optional[str] = Field(
        None,
        description="Some beacons may require a user to provide an authorization key before changing any of its configuration (e.g. broadcast frames, transmit power). This field provides a place to store and control access to that key. This field is populated in responses to `GET /v1beta1/beacons/3!beaconId` from users with write access to the given beacon. That is to say: If the user is authorized to write the beacon's confidential data in the service, the service considers them authorized to configure the beacon. Note that this key grants nothing on the service, only on the beacon itself.",
    )
    status: Optional[Status] = Field(
        None, description='Current status of the beacon. Required.'
    )


class GetInfoForObservedBeaconsRequest(BaseModel):
    namespacedTypes: Optional[List[str]] = Field(
        None,
        description='Specifies what kind of attachments to include in the response. When given, the response will include only attachments of the given types. When empty, no attachments will be returned. Must be in the format namespace/type. Accepts `*` to specify all types in all namespaces owned by the client. Optional.',
    )
    observations: Optional[List[Observation]] = Field(
        None,
        description='The beacons that the client has encountered. At least one must be given.',
    )


class ListBeaconsResponse(BaseModel):
    beacons: Optional[List[Beacon]] = Field(
        None, description='The beacons that matched the search criteria.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='An opaque pagination token that the client may provide in their next request to retrieve the next page of results.',
    )
    totalCount: Optional[str] = Field(
        None,
        description='Estimate of the total number of beacons matched by the query. Higher values may be less accurate.',
    )


class ListNamespacesResponse(BaseModel):
    namespaces: Optional[List[Namespace]] = Field(
        None, description='The attachments that corresponded to the request params.'
    )
